
(define t true)
(define f false)
(define n nil)

(defun (string v)
    (cond
        [(str? v) v]
        [else (literal v)]))


(defun (map fun lst)
    (cond
        [(pair? lst) (let (
            [h (fun (car lst))]
            [t (map fun (cdr lst))])
            (cons h t))]
        [(null? lst) nil]
        [else (fun lst)]))

(defun (filter cnd lst)
    (cond
        [(null? lst) nil]
        [(cnd (car lst)) (cons (car lst) (filter cnd (cdr lst)))]
        [else (filter cnd (cdr lst))]))

(defun (fold fun init lst)
    (define h (car lst))
    (define d (cdr lst))
    (cond
        [(pair? d) (fold fun (fun init h) d)]
        [(null? d) (fun init h)]
        [else (error)]))


(defun (append lst1 lst2)
    (cond
        [(null? lst1) lst2]
        [(null? lst2) lst1]
        [else (cons (car lst1) (append (cdr lst1) lst2))]))

(defun (reduce fun lst)
    (cond
        [(pair? lst) (fold fun (car lst) (cdr lst))]
        [(null? lst) nil]
        [else (error lst)]))


; List[(Sym . V)] -> Sym -> Option[V]
(defun (find record-list key)
    (cond
        [(null? record-list) nil]
        [(eq? (car (car record-list)) key) (cdr (car record-list))]
        [else (find (cdr record-list) key)]))

; List[(Sym . V)] -> Sym -> V
(defun (strict-find record-list key)
    (cond
        [(null? record-list) (error "Key not found")]
        [(eq? (car (car record-list)) key) (cdr (car record-list))]
        [else (strict-find (cdr record-list) key)]))

; (defun (list? lst)
;     (cond
;         [(pair? lst) f]))


(defun (and-list-lazy args)
    (cond
        [(null? args) t]
        [(pair? args)
            (cond
                [(car args) (and-list-lazy (cdr args))]
                [else f])]
        [else (error "or-list-lazy: args is not a list")]))

(defun (or-list-lazy args)
    (cond
        [(null? args) f]
        [(pair? args)
            (cond
                [(car args) t]
                [else (or-list-lazy (cdr args))])]
        [else (error "or-list-lazy: args is not a list")]))

(defun (and . args)
    (and-list-lazy args))

(defun (or . args)
    (or-list-lazy args))

; (defun (and . args)
;     (fold raw-and false args))
;
; (defun (or . args)
;     (fold raw-or false args))


(defun (+ . args)
    (define fun
        (cond
            [(int? (car args)) +i]
            [(uint? (car args)) +u]
            [(float? (car args)) +f]))
    (fold fun 0 args))


(defun (- . args)
    (define fun
        (cond
            [(int? (car args)) -i]
            [(uint? (car args)) -u]
            [(float? (car args)) -f]))
    (reduce fun args))


(defun (* . args)
    (define fun
        (cond
            [(int? (car args)) *i]
            [(uint? (car args)) *u]
            [(float? (car args)) *f]))
    (fold fun 1 args))


(defun (/ . args)
    (define fun
        (cond
            [(int? (car args)) /i]
            [(uint? (car args)) /u]
            [(float? (car args)) /f]))
    (reduce fun args))

